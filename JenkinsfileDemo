// Jenkinsfile (Declarative Pipeline)

pipeline {
    agent any

    // 2. TẠO LỰA CHỌN MÔI TRƯỜNG
    parameters {
        choice(name: 'ENVIRONMENT', 
               choices: ['staging', 'production'], 
               description: 'Chọn môi trường để chạy test')
    }

    options {
        // Add timestamps to logs for easier debugging
        timestamps()
        // Give overall pipeline a reasonable timeout
        timeout(time: 60, unit: 'MINUTES')
    }

    environment {
        // Default compose command; we'll detect the right one at runtime
        COMPOSE_CMD = 'docker-compose'
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Debug File Content') {
            steps {
                echo '=== BẮT ĐẦU NỘI DUNG docker-compose.yml ==='
                sh 'cat ./docker-compose.yml || true'
                echo '=== NỘI DUNG staging.env ==='
                sh 'cat ./staging.env || true'
                echo '=== NỘI DUNG production.env ==='
                sh 'cat ./production.env || true'
            }
        }

        stage('Detect docker-compose') {
            steps {
                script {
                    // Detect whether 'docker compose' (v2) or 'docker-compose' (v1) is available
                    def detected = sh(script: "if docker compose version >/dev/null 2>&1; then echo 'docker compose'; elif docker-compose --version >/dev/null 2>&1; then echo 'docker-compose'; else echo 'docker-compose'; fi", returnStdout: true).trim()
                    env.COMPOSE_CMD = detected
                    echo "Using compose command: ${env.COMPOSE_CMD}"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def envFile = (params.ENVIRONMENT == 'production') ? 'production.env' : 'staging.env'
                    echo "Building images using ${envFile} with ${env.COMPOSE_CMD}"
                    
                    // DEBUG: List workspace files
                    sh "echo 'Files in workspace:'; ls -la *.env 2>/dev/null || echo 'No .env files found'"
                    
                    // Use --env-file when available to ensure substitutions are set during build/run
                    sh "${env.COMPOSE_CMD} --env-file ${envFile} build --pull"
                }
            }
        }

        stage('Run Robot Tests') {
            steps {
                script {
                    def envFile = (params.ENVIRONMENT == 'production') ? 'production.env' : 'staging.env'
                    echo "Running tests on ${params.ENVIRONMENT} using ${envFile}"
                    
                    // DEBUG: Check if env file exists in workspace
                    sh "echo 'Checking for env file:'; [ -f ${envFile} ] && echo '✓ ${envFile} found' || echo '✗ ${envFile} NOT FOUND'"
                    sh "echo 'Content of ${envFile}:'; cat ${envFile} || true"

                    // Run with --exit-code-from so CI picks the test failure exit code
                    // Add --build and --force-recreate to ensure latest image and env are used
                    try {
                        // Use -e to properly substitute environment variables from the file
                        sh """
                            echo "Starting docker-compose with: ${env.COMPOSE_CMD} --env-file ${envFile} up"
                            ${env.COMPOSE_CMD} --env-file ${envFile} up --exit-code-from robot-test --build --force-recreate
                        """
                    } catch (err) {
                        // Ensure we still collect artifacts and then rethrow to mark the build failed
                        echo "Error running docker-compose up: ${err}"
                        throw err
                    }

                }

            }
        }

        stage('Publish Reports') {
            steps {
                echo 'Archiving Robot Framework reports...'
                archiveArtifacts artifacts: 'results/log.html, results/report.html, results/output.xml', allowEmptyArchive: true
            }
        }
    }

    post {
        always {
            script {
                // Try to use detected compose command to tear down; fallback if it fails.
                try {
                    sh "${env.COMPOSE_CMD} down || true"
                } catch (e) {
                    echo "Failed to run ${env.COMPOSE_CMD} down: ${e}"
                    sh 'docker-compose down || true'
                }
            }
        }
    }
}